#!<%= $perl_path %>

# This script is for showing groups in the Puppet node classifier
#
#   Author M. Mallard 15 Feb 2019
#

use strict;
<% if !empty($perl_lib_path) { -%>
use lib '<%= $perl_lib_path %>';
<% } %>
use Data::Dumper;
use String::CamelCase qw( camelize );
use POSIX qw(strftime);
use Puppet::DB;
use Puppet::Classify;
use Term::ANSIColor;
use YAML;
use JSON; # imports encode_json, decode_json, to_json and from_json
use 5.10.0;
use Getopt::Std;

# Command line argument processing
our( $opt_f, $opt_h );
getopts('f:h');
$Getopt::Std::STANDARD_HELP_VERSION = 1;

# Globals
my $config = LoadFile( "<%= $api_access_config_path %>" );
my $json = JSON->new->allow_nonref;

# Create a Puppet DB object
my $puppet_db = Puppet::DB->new(
    server_name => $config->{puppetdb_host},
    server_port => $config->{puppetdb_port},
);

# Create a Puppet classification object
my $classify = Puppet::Classify->new( 
                  cert_name       => $config->{puppet_classify_cert},
                  server_name     => $config->{puppet_classify_host},
                  server_port     => $config->{puppet_classify_port},
                  puppet_ssl_path => $config->{puppet_ssl_path},
                  puppet_db       => $puppet_db,
                );

# Help message
if( $opt_h ){
    say "\n$0 -f [csv|yaml|json] [group substr to match]";
    say;
    say "\t-f data format to output (defaults to json)";
    exit;
}

# Match the group substr specified on the command line
my $group_match = $ARGV[0];

my $groups = $classify->get_groups();

#say Dumper( $groups );
my @ans;
for my $group ( @$groups ){
    push @ans, $group->{name} if $group->{name} =~ /$group_match/;
}
if( $opt_f eq 'csv' ){
    for my $group ( @ans ){
        say $group;
    }
} elsif( $opt_f eq 'yaml' ){
    say Dump( \@ans);
} else {
    say $json->pretty->encode( \@ans );
}

